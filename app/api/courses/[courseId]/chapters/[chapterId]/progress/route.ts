import { NextResponse } from "next/server";

import { db } from "@/lib/db";
import { currentUser } from "@/lib/auth";

export async function PUT(
  req: Request,
  { params }: { params: { courseId: string; chapterId: string } }
) {
  try {
    const user = await currentUser();
    let userId = user?.id ?? "";
  
    const { isCompleted } = await req.json();

    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    } 

    const userProgress = await db.userProgress.upsert({
      where: {
        userId_chapterId: {
          userId,
          chapterId: params.chapterId,
        }
      },
      update: {
        isCompleted
      },
      create: {
        userId,
        chapterId: params.chapterId,
        isCompleted,
      }
    })

    // Check if course is completed and auto-generate certificate
    if (isCompleted) {
      try {
        // Check if all chapters in the course are completed
        const courseChapters = await db.chapter.findMany({
          where: {
            courseId: params.courseId,
            isPublished: true
          }
        });

        const completedChapters = await db.userProgress.findMany({
          where: {
            userId,
            chapterId: {
              in: courseChapters.map(ch => ch.id)
            },
            isCompleted: true
          }
        });

        // If all chapters are completed
        if (completedChapters.length === courseChapters.length && courseChapters.length > 0) {
          // Check if certificate already exists
          const existingCertificate = await db.certificate.findUnique({
            where: {
              userId_courseId: {
                userId,
                courseId: params.courseId
              }
            }
          });

          // Auto-generate certificate if it doesn't exist
          if (!existingCertificate) {
            const course = await db.course.findUnique({
              where: { id: params.courseId },
              include: {
                chapters: {
                  where: { isPublished: true },
                  include: {
                    quizzes: { where: { isPublished: true } },
                    assignments: true
                  }
                }
              }
            });

            if (course) {
              // Calculate totals
              let totalQuizzes = 0;
              let totalAssignments = 0;
              course.chapters.forEach(ch => {
                totalQuizzes += ch.quizzes.length;
                totalAssignments += ch.assignments.length;
              });

              // Generate unique verification code
              const verificationCode = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);

              await db.certificate.create({
                data: {
                  userId,
                  courseId: params.courseId,
                  studentName: user?.name || "Student",
                  studentEmail: user?.email || "",
                  totalChapters: courseChapters.length,
                  completedChapters: completedChapters.length,
                  totalQuizzes,
                  completedQuizzes: 0, // Will be updated in real calculation
                  totalAssignments,
                  completedAssignments: 0, // Will be updated in real calculation
                  totalScore: 0,
                  achievedScore: 0,
                  percentage: 100,
                  verificationCode,
                  isAutoGenerated: true
                }
              });
              
              console.log(`[AUTO_CERTIFICATE] Generated certificate for user ${userId} in course ${params.courseId}`);
            }
          }
        }
      } catch (certError) {
        console.log("[AUTO_CERTIFICATE_ERROR]", certError);
        // Don't fail the progress update if certificate generation fails
      }
    }

    return NextResponse.json(userProgress);
  } catch (error) {
    console.log("[CHAPTER_ID_PROGRESS]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}